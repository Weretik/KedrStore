@using Application.Catalog.Shared
@using Application.Catalog.ImportCatalogFromXml
@using Ardalis.Result
@inject ISender Sender
@inject ISnackbar Snackbar


<MudPaper Class="pa-4">
    <MudStack Spacing="2">
        <MudText Typo="Typo.h5">Імпорт каталогу з XML</MudText>

        <MudSelect T="int" Label="Тип товарів" @bind-Value="_productType" Required="true">
            <MudSelectItem Value="1">Двері</MudSelectItem>
            <MudSelectItem Value="2">Фурнітура</MudSelectItem>
        </MudSelect>

        <MudFileUpload T="IBrowserFile"
                       @ref="_uploader"
                       OnFilesChanged="OnFilesSelected"
                       Placeholder="Перетягни XML сюди або натисни, щоб вибрати"
                       Accept=".xml,application/xml,text/xml"
                       MaxFileCount="1"
                       Class="mt-2" />

        <MudStack Row="true" Spacing="1">
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Disabled="@(!CanImport || _isBusy)"
                       OnClick="ImportAsync">
                Імпортувати
            </MudButton>

            <MudButton Variant="Variant.Outlined"
                       Color="Color.Secondary"
                       Disabled="@(!HasFile || _isBusy)"
                       OnClick="ClearAsync">
                Очистити
            </MudButton>

            <MudButton Variant="Variant.Text"
                       Disabled="@_isBusy"
                       OnClick="OpenPickerAsync">
                Вибрати файл…
            </MudButton>
        </MudStack>

        @if (_isBusy)
        {
            <MudProgressLinear Indeterminate="true" Class="mt-2" />
        }

        @if (!string.IsNullOrWhiteSpace(_fileInfo))
        {
            <MudText Typo="Typo.body2" Class="mt-1">@_fileInfo</MudText>
        }
    </MudStack>
</MudPaper>

@code {
    private MudFileUpload<IBrowserFile>? _uploader;
    private IBrowserFile? _selected;
    private bool _isBusy;
    private int _productType = 1;
    private string? _fileInfo;
    private CancellationTokenSource? _cts;

    private bool HasFile => _selected is not null;
    private bool CanImport => HasFile && (_productType == 1 || _productType == 2);

    private const long MaxXmlBytes = 50L * 1024 * 1024;

    private Task OpenPickerAsync() => _uploader?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private async Task ClearAsync()
    {
        _cts?.Cancel();
        _selected = null;
        _fileInfo = null;
        if (_uploader is not null)
            await _uploader.ClearAsync();
        StateHasChanged();
    }

    private Task OnFilesSelected(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles();

        _selected = files.FirstOrDefault();
        _fileInfo = _selected is null
            ? null
            : $"{_selected.Name} | {FormatSize(_selected.Size)} | {_selected.ContentType}";

        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task ImportAsync()
    {
        if (!CanImport || _selected is null) return;

        _isBusy = true;
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        StateHasChanged();

        try
        {
            var file = ToUploadedFile(_selected);
            var request = new ImportCatalogFromXml(file, _productType);
            var cmd = new ImportCatalogFromXmlCommand(request);

            // Mediator (MIT) + Ardalis.Result: без исключений, всё в Status/Errors
            var result = await Sender.Send(cmd, _cts.Token);

            switch (result.Status)
            {
                case ResultStatus.Ok:
                    Snackbar.Add("Імпорт виконано успішно.", Severity.Success);
                    break;

                case ResultStatus.Invalid:
                    var validation = result.ValidationErrors?
                        .Select(e => e.ErrorMessage) ?? [];

                    var enumerable = validation as string[] ?? validation.ToArray();
                    var msgInvalid = enumerable.Any()
                        ? string.Join("; ", enumerable)
                        : "Дані не пройшли валідацію.";
                    Snackbar.Add(msgInvalid, Severity.Error);
                    break;

                case ResultStatus.Error:
                    var msgError = result.Errors?.Any() == true
                        ? string.Join("; ", result.Errors)
                        : "Під час імпорту сталася помилка.";
                    Snackbar.Add(msgError, Severity.Error);
                    break;

                case ResultStatus.NotFound:
                    Snackbar.Add("Ресурси для імпорту не знайдені.", Severity.Warning);
                    break;

                case ResultStatus.Forbidden:
                    Snackbar.Add("Немає прав на імпорт.", Severity.Warning);
                    break;

                default:
                    Snackbar.Add($"Статус: {result.Status}", Severity.Info);
                    break;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Несподівана помилка: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isBusy = false;
            StateHasChanged();
        }
    }

    private UploadedFile ToUploadedFile(IBrowserFile browserFile) =>
        new(
            FileName: browserFile.Name,
            ContentType: browserFile.ContentType,
            Length: browserFile.Size,
            OpenReadStream: () => browserFile.OpenReadStream(MaxXmlBytes)
        );

    private static string FormatSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        double kb = bytes / 1024d;
        if (kb < 1024) return $"{kb:0.#} KB";
        double mb = kb / 1024d;

        return $"{mb:0.#} MB";
    }

}
